{
    "sorting": {
        "id": "sorting",
        "title": "Sorting Paradigms",
        "description": "Master the art of ordering data efficiently.",
        "modules": [
            {
                "id": "selection_sort",
                "title": "Selection Sort",
                "family": "Sorting",
                "difficulty": "Novice",
                "description": "The simplest 'search and place' strategy.",
                "prerequisites": [],
                "unlocks": [
                    "bubble_sort"
                ],
                "why": "It teaches the concept of 'finding the minimum' repeatedly. While slow, it minimizes memory writes better than almost any other sort.",
                "realWorldUses": [
                    "Flash memory (minimizes writes)",
                    "Simple microcontroller tasks"
                ],
                "visualizerType": "array",
                "academic": {
                    "formalInvariant": "The subarray A[0...i-1] contains the i smallest elements in sorted order.",
                    "proofIntuition": "By always picking the absolute minimum from the unsorted region, we guarantee the next element extends the sorted prefix correctly.",
                    "stability": "Unstable",
                    "inPlace": "Yes",
                    "spaceModel": "O(1) auxiliary space"
                },
                "competitive": {
                    "constraints": "N <= 1000",
                    "optimizationTricks": [
                        "None (strictly O(N^2))"
                    ],
                    "tleRisk": [
                        "Always TLE on N >= 10^4"
                    ],
                    "template": "for i in 0..n: swap(i, min_index(i..n))"
                },
                "interview": {
                    "edgeCases": [
                        "Already sorted array",
                        "Reverse sorted array",
                        "All elements identical"
                    ],
                    "trapSimulation": "Interviewer asks to make it stable. You must explain why default implementation isn't and how using a data structure like a flexible list could allow shifting instead of swapping (making it stable but O(N^3) or O(N^2)).",
                    "wrongAssumptions": [
                        "It terminates early if sorted (it doesn't)"
                    ]
                },
                "performance": {
                    "complexityGraph": [
                        {
                            "inputSize": 10,
                            "time": 100
                        },
                        {
                            "inputSize": 100,
                            "time": 10000
                        },
                        {
                            "inputSize": 1000,
                            "time": 1000000
                        }
                    ],
                    "bestCase": "O(N²)",
                    "averageCase": "O(N²)",
                    "worstCase": "O(N²)"
                },
                "drill": []
            },
            {
                "id": "insertion_sort",
                "title": "Insertion Sort",
                "family": "Sorting",
                "difficulty": "Novice",
                "description": "Builds the final sorted array one item at a time.",
                "prerequisites": [],
                "unlocks": [
                    "shell_sort"
                ],
                "why": "It mimics how humans sort cards. It's extremely efficient for small or partially sorted arrays.",
                "realWorldUses": [
                    "Sorting playing cards",
                    "Final step of QuickSort/TimSort"
                ],
                "visualizerType": "array",
                "academic": {
                    "formalInvariant": "The subarray A[0...i-1] is sorted relative to itself (but not necessarily containing the i smallest elements of the full array).",
                    "proofIntuition": "We insert the new element into the correct position within the already sorted prefix, maintaining the sorted property.",
                    "stability": "Stable",
                    "inPlace": "Yes",
                    "spaceModel": "O(1) auxiliary space"
                },
                "competitive": {
                    "constraints": "N <= 2000 (or N <= 10^5 if array is nearly sorted)",
                    "optimizationTricks": [
                        "Use Binary Search to find insertion point (Reduces comparisons to O(N log N), but shifts still O(N^2))"
                    ],
                    "tleRisk": [
                        "Reverse sorted large array"
                    ],
                    "template": "for i in 1..n: j=i; while j>0 && A[j-1]>A[j]: swap"
                },
                "interview": {
                    "edgeCases": [
                        "Reverse sorted (Max work)",
                        "Already sorted (O(N) work)"
                    ],
                    "trapSimulation": "Interviewer asks for a sort that is fast on a 'streaming' data input. Insertion sort is 'online' and can sort as data arrives.",
                    "wrongAssumptions": [
                        "It's always slow (It's fast for small N)"
                    ]
                },
                "performance": {
                    "complexityGraph": [
                        {
                            "inputSize": 10,
                            "time": 10
                        },
                        {
                            "inputSize": 100,
                            "time": 5000
                        },
                        {
                            "inputSize": 1000,
                            "time": 1000000
                        }
                    ],
                    "bestCase": "O(N)",
                    "averageCase": "O(N²)",
                    "worstCase": "O(N²)"
                },
                "drill": []
            },
            {
                "id": "merge_sort",
                "title": "Merge Sort",
                "family": "Sorting",
                "difficulty": "Adept",
                "description": "Divide and conquer strategy.",
                "prerequisites": [
                    "recursion"
                ],
                "unlocks": [
                    "inversion_count"
                ],
                "why": "The gold standard for stable sorting and handling linked lists.",
                "realWorldUses": [
                    "E-commerce product sorting (needs stability)",
                    "External sorting (database tables)"
                ],
                "visualizerType": "tree",
                "academic": {
                    "formalInvariant": "The merge step combines two sorted subarrays into a single sorted subarray.",
                    "proofIntuition": "Recursively sort left and right halves. Merging two sorted lists is trivial O(N).",
                    "stability": "Stable",
                    "inPlace": "No (Requires O(N) buffer)",
                    "recurrence": "T(n) = 2T(n/2) + O(n)",
                    "spaceModel": "O(N) auxiliary"
                },
                "competitive": {
                    "constraints": "N <= 5 * 10^5",
                    "optimizationTricks": [
                        "Use for counting inversions",
                        "Solve 'reverse pairs' leetcode problems"
                    ],
                    "tleRisk": [
                        "Rare. Very consistent O(N log N)."
                    ],
                    "template": "mid = (l+r)/2; mergeSort(l, mid); mergeSort(mid+1, r); merge()"
                },
                "interview": {
                    "edgeCases": [
                        "Array size 1 or 0",
                        "Odd length arrays"
                    ],
                    "trapSimulation": "Implement it in-place. (Very hard, typically O(N^2 * log N) or O(N log^2 N) for complex algorithms).",
                    "wrongAssumptions": [
                        "It uses O(1) space (It uses O(N))"
                    ]
                },
                "performance": {
                    "complexityGraph": [
                        {
                            "inputSize": 10,
                            "time": 30
                        },
                        {
                            "inputSize": 100,
                            "time": 600
                        },
                        {
                            "inputSize": 1000,
                            "time": 9000
                        }
                    ],
                    "bestCase": "O(N log N)",
                    "averageCase": "O(N log N)",
                    "worstCase": "O(N log N)"
                },
                "drill": []
            },
            {
                "id": "quick_sort",
                "title": "Quick Sort",
                "family": "Sorting",
                "difficulty": "Expert",
                "description": "Partition and conquer.",
                "prerequisites": [
                    "recursion"
                ],
                "unlocks": [
                    "intro_sort"
                ],
                "why": "Often faster than Merge Sort in practice due to cache locality.",
                "realWorldUses": [
                    "Standard library sorts (C++ std::sort)",
                    "General purpose in-memory sort"
                ],
                "visualizerType": "array",
                "academic": {
                    "formalInvariant": "After partition, pivot is in final position. All left < pivot, all right > pivot.",
                    "proofIntuition": "Recursively partition around a pivot. Base cases are size 0 or 1 arrays.",
                    "stability": "Unstable",
                    "inPlace": "Yes (O(log N) stack)",
                    "recurrence": "T(n) = T(k) + T(n-k-1) + O(n)",
                    "spaceModel": "O(log N) stack space"
                },
                "competitive": {
                    "constraints": "N <= 10^6 (if randomized)",
                    "optimizationTricks": [
                        "Random shuffle input first to avoid worst case",
                        "Use 3-way partition for duplicate elements"
                    ],
                    "tleRisk": [
                        "Sorted array with bad pivot choice -> O(N^2)"
                    ],
                    "template": "pivot = partition(arr); quicksort(left); quicksort(right)"
                },
                "interview": {
                    "edgeCases": [
                        "All elements equal (Review 3-way partition)",
                        "Pivot selection strategies"
                    ],
                    "trapSimulation": "Write it to allow tail-call optimization.",
                    "wrongAssumptions": [
                        "It's strictly O(N log N) (Worst case is N^2)"
                    ]
                },
                "performance": {
                    "complexityGraph": [
                        {
                            "inputSize": 10,
                            "time": 25
                        },
                        {
                            "inputSize": 100,
                            "time": 500
                        },
                        {
                            "inputSize": 1000,
                            "time": 8000
                        }
                    ],
                    "bestCase": "O(N log N)",
                    "averageCase": "O(N log N)",
                    "worstCase": "O(N²)"
                },
                "drill": []
            },
            {
                "id": "heap_sort",
                "title": "Heap Sort",
                "family": "Sorting",
                "difficulty": "Expert",
                "description": "Selection sort on steroids using a Heap.",
                "prerequisites": [
                    "selection_sort",
                    "recursion"
                ],
                "unlocks": [],
                "why": "Guaranteed O(N log N) with O(1) space. Excellent for embedded systems.",
                "realWorldUses": [
                    "Linux Kernel",
                    "Embedded systems",
                    "Introsort fallback"
                ],
                "visualizerType": "tree",
                "academic": {
                    "formalInvariant": "The heap property holds for the unsorted region.",
                    "proofIntuition": "Extract-Max is O(log N). Do it N times.",
                    "stability": "Unstable",
                    "inPlace": "Yes",
                    "spaceModel": "O(1) auxiliary"
                },
                "competitive": {
                    "constraints": "N <= 10^6",
                    "optimizationTricks": [
                        "Use std::priority_queue",
                        "Build heap is O(N)"
                    ],
                    "tleRisk": [
                        "Slow constant factors"
                    ],
                    "template": "make_heap(arr); sort_heap(arr);"
                },
                "interview": {
                    "edgeCases": [
                        "Array index 0 vs 1 based heap"
                    ],
                    "trapSimulation": "Implement a stream median finder? (Use two heaps)",
                    "wrongAssumptions": [
                        "Building heap is O(N log N) (It is O(N))"
                    ]
                },
                "performance": {
                    "complexityGraph": [
                        {
                            "inputSize": 10,
                            "time": 30
                        },
                        {
                            "inputSize": 100,
                            "time": 600
                        },
                        {
                            "inputSize": 1000,
                            "time": 9000
                        }
                    ],
                    "bestCase": "O(N log N)",
                    "averageCase": "O(N log N)",
                    "worstCase": "O(N log N)"
                },
                "drill": []
            },
            {
                "id": "radix_sort",
                "title": "Radix Sort",
                "family": "Sorting",
                "difficulty": "Master",
                "description": "Non-comparative integer sorting.",
                "prerequisites": [
                    "counting_sort"
                ],
                "unlocks": [],
                "why": "Breaks the O(N log N) barrier for integers/strings.",
                "realWorldUses": [
                    "Suffix Array",
                    "High-performance integer sort"
                ],
                "visualizerType": "array",
                "academic": {
                    "formalInvariant": "After k-th pass, array is sorted by last k digits.",
                    "proofIntuition": "Stable sort on each digit from LSD to MSD.",
                    "stability": "Stable (required)",
                    "inPlace": "No",
                    "spaceModel": "O(N+K)"
                },
                "competitive": {
                    "constraints": "N <= 10^7 (if range small)",
                    "optimizationTricks": [
                        "Base-256 for bit manipulation"
                    ],
                    "tleRisk": [
                        "Large range spread (K is huge)"
                    ],
                    "template": "for shift in 0..3: counting_sort(arr, shift)"
                },
                "interview": {
                    "edgeCases": [
                        "Negative numbers",
                        "Floating point"
                    ],
                    "trapSimulation": "Sort string formatting.",
                    "wrongAssumptions": [
                        "It's always faster (Cache misses can hurt)"
                    ]
                },
                "performance": {
                    "complexityGraph": [
                        {
                            "inputSize": 10,
                            "time": 10
                        },
                        {
                            "inputSize": 100,
                            "time": 100
                        },
                        {
                            "inputSize": 1000000,
                            "time": 1000000
                        }
                    ],
                    "bestCase": "O(NK)",
                    "averageCase": "O(NK)",
                    "worstCase": "O(NK)"
                },
                "drill": []
            }
        ]
    },
    "searching": {
        "id": "searching",
        "title": "Search Architectures",
        "description": "Navigate data structures to find the needle.",
        "modules": [
            {
                "id": "linear_search",
                "title": "Linear Search",
                "family": "Searching",
                "difficulty": "Novice",
                "description": "The brute force approach.",
                "prerequisites": [],
                "unlocks": [
                    "binary_search"
                ],
                "why": "The baseline for all search algorithms. It works on any iterable data structure.",
                "realWorldUses": [
                    "Finding item in unsorted list",
                    "Debugging"
                ],
                "visualizerType": "array",
                "academic": {
                    "formalInvariant": "The target is not in the checked prefix 0...i-1.",
                    "proofIntuition": "Exhaustive verification.",
                    "stability": "N/A",
                    "inPlace": "Yes",
                    "spaceModel": "O(1)"
                },
                "competitive": {
                    "constraints": "N <= 10^7 (fast)",
                    "optimizationTricks": [
                        "Sentinel Node"
                    ],
                    "tleRisk": [
                        "N > 10^8"
                    ],
                    "template": "for x in arr: if x == target return true"
                },
                "interview": {
                    "edgeCases": [
                        "Empty array",
                        "Target last element"
                    ],
                    "trapSimulation": "Optimize it? (Impossible on unsorted data)",
                    "wrongAssumptions": []
                },
                "performance": {
                    "complexityGraph": [
                        {
                            "inputSize": 10,
                            "time": 10
                        },
                        {
                            "inputSize": 100,
                            "time": 100
                        },
                        {
                            "inputSize": 1000,
                            "time": 1000
                        }
                    ],
                    "bestCase": "O(1)",
                    "averageCase": "O(N)",
                    "worstCase": "O(N)"
                },
                "drill": []
            },
            {
                "id": "binary_search",
                "title": "Binary Search",
                "family": "Searching",
                "difficulty": "Adept",
                "description": "Divide and conquer search.",
                "prerequisites": [
                    "sorting"
                ],
                "unlocks": [
                    "search_on_answer"
                ],
                "why": "The most efficient general comparison search.",
                "realWorldUses": [
                    "Database indexing",
                    "Dictionary lookup"
                ],
                "visualizerType": "array",
                "academic": {
                    "formalInvariant": "If target exists, it is within range [L, R].",
                    "proofIntuition": "Halve the search space every iteration.",
                    "stability": "N/A",
                    "inPlace": "Yes",
                    "spaceModel": "O(1)"
                },
                "competitive": {
                    "constraints": "N <= 10^18 (Conceptually)",
                    "optimizationTricks": [
                        "std::lower_bound",
                        "search on answer space"
                    ],
                    "tleRisk": [
                        "Infinite loop (mid calculation bug)"
                    ],
                    "template": "while L <= R: mid = L+(R-L)/2; if A[mid]==T return mid..."
                },
                "interview": {
                    "edgeCases": [
                        "Overflow (L+R)/2",
                        "Empty array"
                    ],
                    "trapSimulation": "Find first occurrence vs last occurrence.",
                    "wrongAssumptions": [
                        "Array must be distinct"
                    ]
                },
                "performance": {
                    "complexityGraph": [
                        {
                            "inputSize": 10,
                            "time": 3
                        },
                        {
                            "inputSize": 100,
                            "time": 6
                        },
                        {
                            "inputSize": 1000000,
                            "time": 20
                        }
                    ],
                    "bestCase": "O(1)",
                    "averageCase": "O(log N)",
                    "worstCase": "O(log N)"
                },
                "drill": []
            },
            {
                "id": "lower_bound",
                "title": "Lower Bound",
                "family": "Searching",
                "difficulty": "Expert",
                "description": "Find first element >= target.",
                "prerequisites": [
                    "binary_search"
                ],
                "unlocks": [
                    "search_on_answer"
                ],
                "why": "More useful than standard binary search in practice (insertion points, range queries).",
                "realWorldUses": [
                    "C++ std::lower_bound",
                    "Range counts"
                ],
                "visualizerType": "array",
                "academic": {
                    "formalInvariant": "L is the first index where A[L] >= T.",
                    "proofIntuition": "Predicate Logic: F F F T T T. Find first T.",
                    "stability": "N/A",
                    "inPlace": "Yes",
                    "spaceModel": "O(1)"
                },
                "competitive": {
                    "constraints": "N <= 10^18",
                    "optimizationTricks": [
                        "Use valid range [L, R) (half-open)"
                    ],
                    "tleRisk": [
                        "Mid calculation overflow"
                    ],
                    "template": "while L < R: mid = L+(R-L)/2; if A[mid] >= T: R=mid else: L=mid+1"
                },
                "interview": {
                    "edgeCases": [
                        "All < T",
                        "All >= T"
                    ],
                    "trapSimulation": "Implement upper_bound using lower_bound logic.",
                    "wrongAssumptions": []
                },
                "performance": {
                    "complexityGraph": [
                        {
                            "inputSize": 10,
                            "time": 3
                        },
                        {
                            "inputSize": 1000000,
                            "time": 20
                        }
                    ],
                    "bestCase": "O(log N)",
                    "averageCase": "O(log N)",
                    "worstCase": "O(log N)"
                },
                "drill": []
            },
            {
                "id": "search_on_answer",
                "title": "Search on Answer",
                "family": "Searching",
                "difficulty": "Master",
                "description": "Binary search on function output.",
                "prerequisites": [
                    "binary_search"
                ],
                "unlocks": [],
                "why": "Solves 'Min-Max' or 'Max-Min' optimization problems.",
                "realWorldUses": [
                    "Resource allocation",
                    "Aggressive cows problem"
                ],
                "visualizerType": "array",
                "academic": {
                    "formalInvariant": "Function f(x) is monotonic (T, T, ..., F, F). Find last T.",
                    "proofIntuition": "If valid(x) is true, valid(x-1) is true.",
                    "stability": "N/A",
                    "inPlace": "Yes",
                    "spaceModel": "O(1)"
                },
                "competitive": {
                    "constraints": "Answer Range <= 10^18",
                    "optimizationTricks": [
                        "Check function is O(N) or O(log N)"
                    ],
                    "tleRisk": [
                        "Check function too slow"
                    ],
                    "template": "while L < R: mid = (L+R+1)/2; if check(mid): L=mid else: R=mid-1"
                },
                "interview": {
                    "edgeCases": [
                        "Monotonicity assumption violated",
                        "Coordinate compression"
                    ],
                    "trapSimulation": "Allocate pages to students (classic).",
                    "wrongAssumptions": []
                },
                "performance": {
                    "complexityGraph": [
                        {
                            "inputSize": 10,
                            "time": 30
                        },
                        {
                            "inputSize": 1000,
                            "time": 1000
                        }
                    ],
                    "bestCase": "O(N log A)",
                    "averageCase": "O(N log A)",
                    "worstCase": "O(N log A)"
                },
                "drill": []
            }
        ]
    },
    "traversal": {
        "id": "traversal",
        "title": "Graph Traversal",
        "description": "Explore connections and relationships.",
        "modules": [
            {
                "id": "dfs_recursive",
                "title": "DFS (Recursive)",
                "family": "Traversal",
                "difficulty": "Adept",
                "description": "Depth-first exploration.",
                "prerequisites": [
                    "recursion"
                ],
                "unlocks": [
                    "topological_sort"
                ],
                "why": "Crucial for understanding recursion and graph structure.",
                "realWorldUses": [
                    "Maze generation",
                    "Dependency resolution"
                ],
                "visualizerType": "tree",
                "academic": {
                    "formalInvariant": "A node is finished only after all descendants are finished.",
                    "proofIntuition": "Backtracking naturally via stack.",
                    "stability": "N/A",
                    "inPlace": "No (Stack)",
                    "spaceModel": "O(V) worst case depth"
                },
                "competitive": {
                    "constraints": "V <= 10^5",
                    "optimizationTricks": [
                        "Iterative stack to avoid recursion depth limit in Python"
                    ],
                    "tleRisk": [
                        "Dense graph visits"
                    ],
                    "template": "vis[u]=true; for v in adj[u]: if !vis[v] dfs(v)"
                },
                "interview": {
                    "edgeCases": [
                        "Disconnected components",
                        "Cycles"
                    ],
                    "trapSimulation": "Find shortest path with DFS? (No, finds A path)",
                    "wrongAssumptions": []
                },
                "performance": {
                    "complexityGraph": [],
                    "bestCase": "O(V+E)",
                    "averageCase": "O(V+E)",
                    "worstCase": "O(V+E)"
                },
                "drill": []
            },
            {
                "id": "bfs_standard",
                "title": "BFS (Standard)",
                "family": "Traversal",
                "difficulty": "Adept",
                "description": "Breadth-first exploration.",
                "prerequisites": [],
                "unlocks": [
                    "dijkstra"
                ],
                "why": "Finds shortest path in unweighted graphs.",
                "realWorldUses": [
                    "Social networks",
                    "GPS",
                    "Web crawling"
                ],
                "visualizerType": "graph",
                "academic": {
                    "formalInvariant": "Nodes are visited in non-decreasing order of distance from source.",
                    "proofIntuition": "Queue layer by layer.",
                    "stability": "N/A",
                    "inPlace": "No (Queue)",
                    "spaceModel": "O(W) max width"
                },
                "competitive": {
                    "constraints": "V+E <= 10^6",
                    "optimizationTricks": [
                        "Multi-source BFS"
                    ],
                    "tleRisk": [
                        "Revisiting nodes"
                    ],
                    "template": "Q.push(s); while Q: u=Q.pop(); for v in adj[u]: if !vis[v]: vis[v]=1, Q.push(v)"
                },
                "interview": {
                    "edgeCases": [
                        "Disconnected graph",
                        "Target unreachable"
                    ],
                    "trapSimulation": "BFS on weighted graph? (Fails)",
                    "wrongAssumptions": []
                },
                "performance": {
                    "complexityGraph": [],
                    "bestCase": "O(V+E)",
                    "averageCase": "O(V+E)",
                    "worstCase": "O(V+E)"
                },
                "drill": []
            },
            {
                "id": "01_bfs",
                "title": "0-1 BFS",
                "family": "Traversal",
                "difficulty": "Expert",
                "description": "Shortest path with edge weights 0 or 1.",
                "prerequisites": [
                    "bfs_standard",
                    "dijkstra"
                ],
                "unlocks": [],
                "why": "More efficient than Dijkstra for binary weighted graphs.",
                "realWorldUses": [
                    "Grid movement (smooth vs rough terrain)",
                    "Deque operations"
                ],
                "visualizerType": "graph",
                "academic": {
                    "formalInvariant": "Nodes in deque are always sorted by distance.",
                    "proofIntuition": "Push 0-edges to front, 1-edges to back.",
                    "stability": "N/A",
                    "inPlace": "No (Deque)",
                    "spaceModel": "O(V)"
                },
                "competitive": {
                    "constraints": "V+E <= 10^6",
                    "optimizationTricks": [
                        "Use std::deque"
                    ],
                    "tleRisk": [
                        "Using Dijkstra (O(E log V) vs O(E))"
                    ],
                    "template": "deque dq; dq.push_front(s); dist[s]=0;"
                },
                "interview": {
                    "edgeCases": [
                        "Negative edges (not allowed)",
                        "Weights > 1"
                    ],
                    "trapSimulation": "Explain why Dijkstra is overkill here.",
                    "wrongAssumptions": []
                },
                "performance": {
                    "complexityGraph": [],
                    "bestCase": "O(V+E)",
                    "averageCase": "O(V+E)",
                    "worstCase": "O(V+E)"
                },
                "drill": []
            },
            {
                "id": "multi_source_bfs",
                "title": "Multi-Source BFS",
                "family": "Traversal",
                "difficulty": "Expert",
                "description": "Shortest path from multiple starting points.",
                "prerequisites": [
                    "bfs_standard"
                ],
                "unlocks": [],
                "why": "Finds nearest special node from any point in the graph simultaneously.",
                "realWorldUses": [
                    "Virus spread simulation",
                    "Nearest police station"
                ],
                "visualizerType": "graph",
                "academic": {
                    "formalInvariant": "Distance is min(dist(s_i, v)) for all sources s_i.",
                    "proofIntuition": "Imagine a super-source connected to all sources with weight 0.",
                    "stability": "N/A",
                    "inPlace": "No",
                    "spaceModel": "O(V)"
                },
                "competitive": {
                    "constraints": "V+E <= 10^6",
                    "optimizationTricks": [
                        "Push all sources to Q at t=0"
                    ],
                    "tleRisk": [
                        "Running BFS for each source (O(S*(V+E)))"
                    ],
                    "template": "for s in sources: Q.push(s), dist[s]=0"
                },
                "interview": {
                    "edgeCases": [
                        "Overlapping sources"
                    ],
                    "trapSimulation": "Rotting Oranges LeetCode problem.",
                    "wrongAssumptions": []
                },
                "performance": {
                    "complexityGraph": [],
                    "bestCase": "O(V+E)",
                    "averageCase": "O(V+E)",
                    "worstCase": "O(V+E)"
                },
                "drill": []
            }
        ]
    },
    "recursion": {
        "id": "recursion",
        "title": "Recursion Patterns",
        "description": "The art of self-reference.",
        "modules": [
            {
                "id": "recursion",
                "title": "Recursion Basics",
                "family": "Recursion",
                "difficulty": "Novice",
                "description": "Solving problems by solving smaller instances.",
                "prerequisites": [],
                "unlocks": [
                    "merge_sort",
                    "dfs_recursive"
                ],
                "why": "Recursion is the foundation of advanced algorithms.",
                "realWorldUses": [
                    "JSON parsing",
                    "DOM Trees"
                ],
                "visualizerType": "tree",
                "academic": {
                    "formalInvariant": "Base case terminates, recursive step reduces entropy.",
                    "proofIntuition": "Induction.",
                    "stability": "N/A",
                    "inPlace": "N/A",
                    "spaceModel": "Stack depth"
                },
                "competitive": {
                    "constraints": "Depth <= 10^4",
                    "optimizationTricks": [
                        "Memoization (DP)"
                    ],
                    "tleRisk": [
                        "Exponential branching without memoization"
                    ],
                    "template": "if base: return; recurse()"
                },
                "interview": {
                    "edgeCases": [
                        "Stack overflow"
                    ],
                    "trapSimulation": "Tail recursion optimization discussion.",
                    "wrongAssumptions": []
                },
                "performance": {
                    "complexityGraph": [],
                    "bestCase": "O(N)",
                    "averageCase": "O(N)",
                    "worstCase": "O(2^N)"
                },
                "drill": [
                    {
                        "id": "rec_1",
                        "type": "invariant_identification",
                        "question": "What is the most critical part of a recursive function?",
                        "scenario": "Writing a factorial function.",
                        "options": [
                            "The return type",
                            "The base case",
                            "The recursive call",
                            "The arguments"
                        ],
                        "correctAnswer": "The base case",
                        "explanation": "Without a valid base case, recursion becomes an infinite loop leading to a stack overflow."
                    }
                ]
            }
        ]
    }
}